# Coding style masterclass



# Topics
* **C/C++ programming language**
* Coding style
* Compiler
* Algorithms
* Data structures



# C/C++ programming language

* Basics of C++
* Control structures
* Compound data types
* Object oriented programming
* Advanced concepts



# Basics of C++
* Structure of the program
* Variables. Data Types
* Constants
* Operators
* Basic Input/Output


## Structure of the program
```c++
// my first program in C++
#include <iostream>
using namespace std;

int main () {
    cout << "Hello World!";
    return 0; 
}
```


## Variables. Data Types
* Basic data types:
```cpp
char, short int (short), int, long int (long),
bool, float, double, long double, wchar_t
```
* Variable declaration
```cpp
int a, b, c;
int a;
int b;
int c;
short Year;
short int Year;
unsigned NextYear;
unsigned int NextYear;
```


## Scope
```cpp
#include <iostream>
using namespace std;

int Integer;
char aCharacter;
char string;
unsigned int NumberOfSons;

int main() {
    unsigned short Age;
    float ANumber, AnotherOne;
    ...
    cout << "Enter your age";
    cin >> Age;
}
```


## Initialization of variables
By default the contents of variable are undefined
```cpp
type identifier = initial_value ;
type identifier (initial_value) ;

int a = 0;
int a (0);
```



# Control structures
* Control structures
* Functions


## The do-while loop
```cpp
do {
	cout << "Enter number (0 to end): ";
	cin >> n;
	cout << "You entered: " << n << "\n";
} while (n != 0);
```


### For loop
```cpp
for ( n=0, i=100 ; n!=i ; n++, i-- ) {
   // whatever here...
}
```


### Functions with no type. The use of void.


## Arguments passed by value and by reference.
```cpp
#include <iostream>
using namespace std;
void duplicate (int& a, int& b, int& c)
{
	a*=2;
	b*=2;
	c*=2;
}
int main () {
	int x=1, y=3, z=7;
	duplicate (x, y, z);
	cout << "x=" << x << ", y=" << y << ", z=" << z; return 0;
}
```


## Default values in parameters.
```cpp
// default values in functions
#include <iostream>
using namespace std;
int divide (int a, int b=2) {
  int r;
  r=a/b;
  return (r);
}
int main () {
  cout << divide (12);
  cout << endl;
  cout << divide (20,4);
  return 0;
}
```


## Overloaded functions.
```cpp
int operate (int a, int b) {
	return (a*b);
}
float operate (float a, float b) {
	return (a/b);
}
int main () {
	int x=5,y=2;
	float n=5.0,m=2.0;
	cout << operate (x,y);
	cout << "\n";
	cout << operate (n,m);
	cout << "\n";
	return 0;
}
```


## Inline functions
The inline specifier indicates the compiler that inline substitution is preferred to the usual function call mechanism for a specific function. This does not change the behavior of a function itself, but is used to suggest to the compiler that the code generated by the function body is inserted at each point the function is called, instead of being inserted only once and perform a regular call to it, which generally involves some additional overhead in running time.



# Compound data types
* Array
* Character Sequences
* Pointers
* Dynamic Memory
* Data structures
* Other Data Types


## Array
```cpp
int billy [5];
int billy [5] = { 16, 2, 77, 40, 12071 };
// arrays example
#include <iostream>
using namespace std;
int billy [] = {16, 2, 77, 40, 12071};
int n, result=0;
int main () {
  for ( n=0 ; n<5 ; n++ )
  {
    result += billy[n];
  }
  cout << result;
return 0; }
```


## Multidimensional arrays
```cpp
// multidimensional array
#define WIDTH 5
#define HEIGHT 3
int jimmy [HEIGHT][WIDTH];
int main () {
	for (int n = 0; n < HEIGHT; n++) {
		for (int m = 0; m < WIDTH; m++) {
			{
				jimmy[n][m]=(n + 1) * (m + 1);
			}
		}
	}
	return 0;
}
// pseudo-multidimensional array
#define WIDTH 5
#define HEIGHT 3
int jimmy [HEIGHT * WIDTH];
int main () {
	for (int n = 0; n < HEIGHT; n++) {
		for (int m = 0; m < WIDTH; m++) {
			{
				jimmy[n*WIDTH+m]=(n+1)*(m+1);
			}
		}
	}
	return 0;
}
```


## Arrays as parameters
```cpp
void procedure (int arg[])
void procedure (int myarray[][3][4])
```


## Character Sequences
```cpp
char myword [] = { 'H', 'e', 'l', 'l', 'o', '\0' };
char myword [] = "Hello";
```


## Pointers
* Reference operator (&)
* Dereference operator (*)


## Declaring variables of pointer types
```cpp
int * number;
char * character;
float * greatnumber;
```


## void pointers
The void type of pointer is a special type of pointer. In C++, void represents the absence of type, so void pointers are pointers that point to a value that has no type (and thus also an undetermined length and undetermined dereference properties).
Always have to cast the address in the void pointer to some other pointer type that points to a concrete data type before dereferencing it.


## Pointers to functions
```cpp
// pointer to functions
#include <iostream>
using namespace std;
int addition (int a, int b) { return (a+b); }
int subtraction (int a, int b) { return (a-b); }
int operation (int x, int y, int (*functocall)(int,int)) {
  int g;
  g = (*functocall)(x,y);
  return (g);
}
int main () {
  int m,n;
  int (*minus)(int,int) = subtraction;
  m = operation (7, 5, addition);
  n = operation (20, m, minus);
  cout <<n;
  return 0;
}

```


## Dynamic Memory
```cpp
int bobby[] = new int [5];
bobby = new (nothrow) int [5];
if (bobby == 0) {
// error assigning memory. Take measures.
};
delete bobby;
delete [] bobby;
```


## Data structures
```cpp
struct movies_t {
  string title;
  int year;
} films [N_MOVIES];

struct friends_t {
  string name;
  string email;
  movies_t favorite_movie;
} charlie, maria;
```


## Other Data Types
### Defined data types (typedef)
C++ allows the definition of our own types based on other existing data types.
```cpp
 typedef char C;
typedef unsigned int WORD;
typedef char * pChar;
typedef char field [50];
```


## Unions
Unions allow one same portion of memory to be accessed as different data types, since all of them are in fact the same location in memory.

All the elements of the union declaration occupy the same physical space in memory. Its size is the one of the greatest element of the declaration.


## Example
```cpp
 union mix_t {
  long l;
  struct {
    short hi;
    short lo;
    } s;
  char c[4];
} mix;
```


## Enumerations (enum)
Enumerations create new data types to contain something different that is not limited to the values fundamental data types may take.
```cpp
enum colors_t {black, blue, green, cyan, red, purple, yellow, white};
```
We can explicitly specify an integer value for any of the constant values that our enumerated type can take.
```cpp
enum months_t { january=1, february, march, april, may, june, july, august,
september, october, november, december} y2k;
```



# Object Oriented Programming
* Classes
* Friendship and inheritance
* Polymorphism


## Classes (I)
A class is an expanded concept of a data structure: instead of holding only data, it can hold both data and functions.

An object is an instantiation of a class. In terms of variables, a class would be the type, and an object would be the variable.


### Access specifier
These specifiers modify the access rights that the members following them acquire:
* **private** members of a class are accessible only from within other members of the same class or from their friends.
* **protected** members are accessible from members of their same class and from their friends, but also from members of their derived classes.
* Finally, **public** members are accessible from anywhere where the object is visible.


### Example
By default, all members of a class declared with the class keyword have private access for all its members.
```cpp
class CRectangle {
    int x, y;
public:
    void set_values (int,int);
    int area (void);
} rect;
```


### Example continued
```cpp
// classes example
#include <iostream>
using namespace std;
class CRectangle {
	int x, y;
public:
	void set_values (int,int);
	int area () {return (x*y);}
};
void CRectangle::set_values (int a, int b) {
	x = a;
	y = b;
}
int main () {
	CRectangle rect;
	rect.set_values (3,4);
	cout << "area: " << rect.area();
	return 0;
} 
```


### Constructor
Objects generally need to initialize variables or assign dynamic memory during their process of creation to become operative and to avoid returning unexpected values during their execution.
```cpp
class CRectangle {
    int width, height;
public:
    CRectangle (int a, int b);
    int area () {return (width*height);}
};
CRectangle::CRectangle (int a, int b) {
    width = a;
    height = b;
}

CRectangle rect (3,4);
CRectangle rectb (5,6);
```


### Destructor
The destructor fulfills the opposite functionality. It is automatically called when an object is destroyed, either because its scope of existence has finished (for example, if it was defined as a local object within a function and the function ends) or because it is an object dynamically assigned and it is released using the operator delete.


### Example
```cpp
class CRectangle {
    int *width, *height;
public:
    CRectangle (int a, int b);
    ~CRectangle ();
    int area () {return (*width * *height);}
};
CRectangle::CRectangle (int a, int b) {
    width = new int;
    height = new int;
    *width = a;
*height = b; }
CRectangle::~CRectangle () {
    delete width;
    delete height;
}
```


### Overloading constructor
Like any other function, a constructor can also be overloaded with more than one function that have the same name but different types or number of parameters.
```cpp
#include <iostream>
using namespace std;
class CRectangle {
    int width, height;
public:
    CRectangle ();
    CRectangle (int,int);
    int area (void) {return (width*height);}
};
CRectangle rect (3,4);
CRectangle rectb;// note absence of parenthesis
```


### Default constructor
If you do not declare any constructors in a class definition, the compiler assumes the class to have a default constructor with no arguments.

But as soon as you declare your own constructor for a class, the compiler no longer provides an implicit default constructor.

Compiler provides three special member functions in total that are implicitly declared if you do not declare your own. These are the **copy constructor**, the **copy assignment operator**, and the **default destructor**.


### Classes defined with struct and union
Classes can be defined not only with keyword **class**, but also with keywords **struct** and **union**.

Classes declared with the keyword struct have public access by default, while members of classes declared with the keyword class have private access.

Unions is different from that of classes declared with struct and class, since unions only store one data member at a time, but nevertheless they are also classes and can thus also hold function members.


## Classes (II)


### Overloading operators
```cpp
int a, b, c;
a = b + c;
...
struct {
    string product;
    float price;
} a, b, c;
a = b + c;// ???
```
Overloadable operators:
```
+ - * / = < > += -= *= /= << >> <<= >>= == != <= >= ++ -- % & ^ ! |
~ &= ^= |= && || %= [] () , ->* -> new delete new[] delete[]
```

```
type operator sign (parameters) { /*...*/ }
```


### Example
```cpp
class CVector {
public:
	int x,y;
	CVector () {};
	CVector (int,int);
	CVector operator + (CVector);
};
CVector::CVector (int a, int b) {
	x = a;
	y = b;
}
CVector CVector::operator+ (CVector param) {
	CVector temp;
	temp.x = x + param.x;
	temp.y = y + param.y;
	return (temp);
}
```


### Keyword this
The keyword **this** represents a pointer to the object whose member function is being executed. It is a pointer to the object itself.
```cpp
CVector& CVector::operator= (const CVector& param) {
    x = param.x;
    y = param.y;
    return *this;
}
```


### Static members
Static members have the same properties as global variables but they enjoy class scope.
Their content is not different from one object of this class to another.
```cpp
class CDummy {
public:
	static int n;
	CDummy () { n++; };
	~CDummy () { n--; };
};
int CDummy::n=0;
```


## Friendship and inheritance
In principle, private and protected members of a class cannot be accessed from outside the same class in which they are declared. However, this rule does not affect **friends**.

Friends are functions or classes declared as such.


### Friend functions
```cpp
class CRectangle {
	int width, height;
public:
	void set_values (int, int);
	int area () {return (width * height);}
	friend CRectangle duplicate (CRectangle);
};

void CRectangle::set_values (int a, int b) {
	width = a;
	height = b;
}

CRectangle duplicate (CRectangle rectparam) {
	CRectangle rectres;
	rectres.width = rectparam.width*2;
	rectres.height = rectparam.height*2;
	return (rectres);
}
```


### Friend classes
```cpp
class CSquare;

class CRectangle {
	int width, height;
public:
	int area () {return (width * height);}
	void convert (CSquare a);
};

class CSquare {
private:
	int side;
public:
	void set_side (int a){side=a;}
	friend class CRectangle;
};

void CRectangle::convert (CSquare a) {
	width = a.side;
	height = a.side;
}
```


### Inheritance between classes
Inheritance allows to create classes which are derived from other classes, so that they automatically include some of its "parent's" members, plus its own.

Declaration of the derived class uses the following format:
```cpp
class derived_class_name: public base_class_name { /*...*/ };
```
This access specifier describes the minimum access level for the members that are inherited from the base class.


### Example
```cpp
class CPolygon {
protected:
	int width, height;
public:
	void set_values (int a, int b) { width=a; height=b;}
};
class CRectangle: public CPolygon {
public:
	int area () { return (width * height); }
};
class CTriangle: public CPolygon {
public:
	int area () { return (width * height / 2); }
};
```


### What is inherited from the base class?
Derived class inherits every member of a base class except:
* its constructor and its destructor
* its operator=() members
* its friends

Although the constructors and destructors are not inherited, default constructor (constructor with no parameters) and its destructor are always called when a new object of a derived class is created or destroyed.


### Example
```cpp
class mother {
public:
	mother () { cout << "mother: no parameters\n"; }
	mother (int a) { cout << "mother: int parameter\n"; }
};
class daughter : public mother {
public:
	daughter (int a) { cout << "daughter: int parameter\n\n"; }
};
class son : public mother {
public:
	son (int a) : mother (a) { cout << "son: int parameter\n\n"; }
};
```


### Multiple inheritance
In C++ it is perfectly possible that a class inherits members from more than one class.
```cpp
class CRectangle: public CPolygon, public COutput; 
class CTriangle: public CPolygon, public COutput;
```


## Polymorphism


### Pointers to base class
One of the key features of derived classes is that a pointer to a derived class is type-compatible with a pointer to its base class.


### Example
```cpp
class CPolygon {
protected:
	int width, height;
public:
	void set_values (int a, int b) { width=a; height=b; }
};
class CRectangle: public CPolygon {
public:
	int area () { return (width * height); }
};
class CTriangle: public CPolygon {
public:
	int area () { return (width * height / 2); }
};
int main () {
	CRectangle rect;
	CTriangle trgl;
	CPolygon * ppoly1 = &rect;
	CPolygon * ppoly2 = &trgl;
	ppoly1->set_values (4,5);
	ppoly2->set_values (4,5);
	cout << rect.area() << endl;
	cout << trgl.area() << endl;
	return 0;
}
```


### Virtual members
A member of a class that can be redefined in its derived classes is known as a virtual member.
```cpp
class CPolygon {
protected:
	int width, height;
public:
	void set_values (int a, int b) { width=a; height=b; }
	virtual int area () { return (0); }
};
class CRectangle: public CPolygon {
public:
	int area () { return (width * height); }
};
class CTriangle: public CPolygon {
public:
	int area () { return (width * height / 2); }
};
```


 
### Abstract base classes
The main difference between an abstract base class and a regular polymorphic class is that because in abstract base classes at least one of its members lacks implementation we cannot create instances (objects) of it.

We can create pointers to it and take advantage of all its polymorphic abilities.


### Example
```cpp
 // abstract class CPolygon
class CPolygon {
protected:
	int width, height;
public:
	void set_values (int a, int b) { width=a; height=b; }
	virtual int area () =0;
};
```



# Advanced concepts
* Templates
* Namespaces
* Exceptions
* ~~Type Casting~~
* ~~Preprocessor directives~~


## Function templates
Function templates are special functions that can operate with generic types.

In C++ this can be achieved using template parameters.

The format for declaring function templates with type parameters is:
```cpp
template <class identifier> function_declaration;
template <typename identifier> function_declaration; 
```


### Example of funciton templates
```cpp
template <class myType>
myType GetMax (myType a, myType b) {
    return (a>b?a:b);
}
```
```cpp
int x, y;
double w, z;
...
GetMax<int>(x, y);
GetMax<double>(z, w);
```


### Example of more than one parameter
```cpp
template <class T, class U>
T GetMin (T a, U b) {
    return (a<b?a:b);
}
```
```cpp
int i, j;
long l;
i = GetMin<int,long> (j, l);
i = GetMin (j,l);
```


## Class templates
We also have the possibility to write class templates, so that a class can have members that use template parameters as types. For example:
```cpp
template <class T>
class mypair {
    T values [2];
public:
    mypair(T first, T second) {
        values[0]=first; values[1]=second;
    }
}; 
mypair<int> myobject (115, 36);
mypair<double> myfloats (3.0, 2.18);

```


### Template specializtion
If we want to define a different implementation for a template when a specific type is passed as template parameter, we can declare a specialization of that template.

We precede the class template name with an empty `template<\>` parameter list to explicitly declare it as a template specialization. 


```cpp
// template specialization
#include <iostream>
using namespace std;
// class template:
template <class T>
class mycontainer {
	T element;
public:
	mycontainer (T arg) {element=arg;}
	T increase () {return ++element;}
};
// class template specialization:
template <>
class mycontainer <char> {
	char element;
public:
	mycontainer (char arg) {element=arg;}
	char uppercase () {
		if ((element >= 'a') && (element <= 'z'))
			element+='A'-'a';
		return element;
	}
};
	int main () {
		mycontainer<int> myint (7);
		mycontainer<char> mychar ('j');
		cout << myint.increase() << endl;
		cout << mychar.uppercase() << endl;
		return 0;
	}
}
```


### Non-type parameters for templates
Besides the template arguments that are preceded by the class or typename keywords , which represent types, templates can also have regular typed parameters, similar to those found in functions.


```cpp
template <class T, int N>
class mysequence {
	T memblock [N];
public:
	void setmember (int x, T value);
	T getmember (int x);
};
 
```


### Templates and multiple file projects
From the point of view of the compiler, templates are not normal functions or classes.

Because templates are compiled when required, this forces a restriction for multi-file projects: the implementation (definition) of a template class or function must be in the same file as its declaration.


## Namespaces
Namespaces allow to group entities like classes, objects and functions under a name.

This way the global scope can be divided in "sub-scopes", each one with its own name.

```cpp
namespace myNamespace
{
    int a, b; 
}
myNamespace::a
myNamespace::b

```


### using
The keyword using is used to introduce a name from a namespace into the current declarative region.
```cpp
namespace first {
	int x = 5;
	int y = 10;
}
namespace second {
	double x = 3.1416;
	double y = 2.7183;
}
int main () {
	using first::x;
	using second::y;
	cout << x << endl;
	cout << y << endl;
	cout << first::y << endl;
	cout << second::x << endl;
	return 0;
}
```


## Exceptions
Exceptions provide a way to react to exceptional circumstances (like runtime errors) in our program by transferring control to special functions called handlers.
```cpp
int main () {
	try
	{
		throw 20;
	}
	catch (int e)
	{
		cout << "An exception occurred. "
		cout << "Exception Nr. " << e << endl;
	}
	return 0;
}
```


### Multiple exceptions handler
If we use an ellipsis (...) as the parameter of catch, that handler will catch any exception no matter what the type of the throw exception is. 

This can be used as a default handler
```cpp
try {
  // code here
}
catch (int param) { cout << "int exception"; } 
catch (char param) { cout << "char exception"; } 
catch (...) { cout << "default exception"; }
```


### Exception specification
When declaring a function we can limit the exception type it might directly or indirectly throw by appending a throw suffix to the function declaration:
```cpp
float myfunction (char param) throw (int); // only int exception
int myfunction (int param) throw(); // no exceptions allowed 
int myfunction (int param); // all exceptions allowed
```


### Standard exceptions
The C++ Standard library provides a base class specifically designed to declare objects to be thrown as exceptions. It is called exception and is defined in the exception header file under the namespace std.
```cpp
// standard exceptions
#include <iostream>
#include <exception>
using namespace std;
class myexception: public exception {
	virtual const char* what() const throw()
	{
		return "My exception happened";
	}
} myex;
int main () {
	try
	{
		throw myex;
	}
	catch (exception& e)
	{
		cout << e.what() << endl;
	}
	return 0;
}
```



# Homework
* Implement matrix class
    * Template based matrix class `<`type -- double or float, size`>`
    *
    * Implement matrix multiplication (speed is not concern)
        * Throw exception if parameters are not valid
    * Implement matrix access using operator
    * Write simple test program
